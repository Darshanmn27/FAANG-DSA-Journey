# ðŸ“Š Sort Elements of an Array by Frequency

## ðŸ’¡ Problem Statement
Given an array of integers, having some duplicate elements, sort the array by frequency. If two elements have the same frequency, sort them in increasing order.

### ðŸ”¥ Example 1:
**Input:**
```
N = 8
array[] = {1,2,3,2,4,3,1,2}
```

**Output:**
```
2 2 2 1 1 3 3 4
```

**Explanation:**
- Element `2` appears **3 times** â†’ Print it 3 times.
- Element `1` appears **2 times** â†’ Print it 2 times.
- Element `3` appears **2 times** â†’ Print it 2 times.
- Element `4` appears **1 time** â†’ Print it 1 time.

The highest frequency element should appear first.

---

### ðŸ”¥ Example 2:
**Input:**
```
N = 6
array[] = {-199,6,7,-199,3,5}
```

**Output:**
```
-199 -199 3 5 6 7
```

**Explanation:**
- Element `-199` appears **2 times** â†’ Print it 2 times.
- Elements `3, 5, 6, 7` appear **1 time each** â†’ Print in sorted order.

---

## ðŸ’¯ Approach 1: Brute Force Solution (O(N^2))

### âœ… Steps to Solve:
1. Traverse the array.
2. Count the frequency of each element manually.
3. Print the elements according to their frequency.
4. Time Complexity: **O(N^2)**

### ðŸ’» Code:
```java
public static void bruteForce(int[] arr) {
   // Traverse each element and count its frequency
}
```

### ðŸ“Š Time Complexity: O(N^2)
### ðŸ’¾ Space Complexity: O(1)

---

## ðŸ’¯ Approach 2: Better Solution Using HashMap (O(N log N))

### âœ… Steps to Solve:
1. Use a **HashMap** to store frequency.
2. Convert HashMap keys to a list.
3. Sort the list by frequency and then by value.
4. Print the result.

### ðŸ’» Code:
```java
public static void betterSolution(int[] arr) {
   HashMap<Integer, Integer> map = new HashMap<>();
   // Count frequency
   for (int i : arr) {
       map.put(i, map.getOrDefault(i, 0) + 1);
   }

   List<Integer> list = new ArrayList<>(map.keySet());
   Collections.sort(list, (a, b) -> {
       if (map.get(a).equals(map.get(b))) return a - b;
       return map.get(b) - map.get(a);
   });
}
```

### ðŸ“Š Time Complexity: O(N log N)
### ðŸ’¾ Space Complexity: O(N)

---

## ðŸ’¯ Approach 3: Optimal Solution Using PriorityQueue (O(N log N))

### âœ… Steps to Solve:
1. Use **HashMap** to count frequency.
2. Use **PriorityQueue (MaxHeap)** to sort by frequency.
3. Extract elements from PriorityQueue and print them.

### ðŸ’» Code:
```java
public static void optimalSolution(int[] arr) {
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i : arr) {
        map.put(i, map.getOrDefault(i, 0) + 1);
    }

    PriorityQueue<Map.Entry<Integer, Integer>> maxHeap =
        new PriorityQueue<>((a, b) -> {
            if (a.getValue().equals(b.getValue())) return a.getKey() - b.getKey();
            return b.getValue() - a.getValue();
        });

    maxHeap.addAll(map.entrySet());
}
```

### ðŸ“Š Time Complexity: O(N log N)
### ðŸ’¾ Space Complexity: O(N)

---

## âœ… Output
```
Brute Force Solution:
2 2 2 1 1 3 3 4

Better Solution:
2 2 2 1 1 3 3 4

Optimal Solution:
2 2 2 1 1 3 3 4
```


