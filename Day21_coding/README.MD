# ðŸ”¥ Search Element in Rotated Sorted Array (Using Binary Search)

## ðŸ“œ Problem Statement
Given a **rotated sorted array** of distinct integers `arr[]` and a target value `target`, write a function to **search the target in the array**.

The array is sorted in ascending order, but it has been rotated **at some pivot** unknown to you. Your task is to find the index of the target if it exists, otherwise return -1.

ðŸ‘‰ **You must solve it in O(log N) time complexity.**

### âœ… Constraints
- Array is rotated at some pivot (unknown).
- Array elements are distinct.
- You need to find the target index.
- If the target does not exist, return -1.

---

## ðŸ“Š Example Input & Output

| Input Array      | Target | Output (Index) |
|-----------------|--------|----------------|
| [4,5,6,7,0,1,2] | 0      | 4              |
| [4,5,6,7,0,1,2] | 3      | -1             |
| [1]             | 0      | -1             |

---

## ðŸ’¡ Approach 1: Brute Force Solution (Linear Search)

### âœ… Logic
- Traverse the entire array.
- Compare each element with the target.
- If found, return the index.
- Otherwise, return -1.

### ðŸ’» Code (Brute Force Solution)
```java
public class SearchInRotatedSortedArray {
    public static void main(String[] args) {
        int arr[] = {4, 5, 6, 7, 0, 1, 2};
        int target = 0;

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                System.out.println("Element found at index: " + i);
                return;
            }
        }
        System.out.println("Element not found");
    }
}
```

### âœ… Dry Run
| Index | Element | Target = 0 | Found?  |
|-------|---------|------------|--------|
| 0     | 4       | âŒ         | No     |
| 1     | 5       | âŒ         | No     |
| 2     | 6       | âŒ         | No     |
| 3     | 7       | âŒ         | No     |
| 4     | 0       | âœ…         | Yes    |

ðŸ‘‰ **Output:** Element found at index: 4

### âœ… Time Complexity
| Operation     | Time Complexity |
|---------------|-----------------|
| Traverse Array | O(N)            |

### âœ… Space Complexity
| Space Used | Space Complexity |
|------------|-----------------|
| No Extra Space | O(1)          |

---

## ðŸ’¡ Approach 2: Better Solution (Divide and Conquer)

### âœ… Logic
- Identify the pivot where the array is rotated.
- Apply Binary Search in two halves of the array.
- If found, return the index.
- Otherwise, return -1.

### ðŸ’» Code (Divide and Conquer Solution)
```java
public class SearchInRotatedSortedArray {
    public static void main(String[] args) {
        int arr[] = {4, 5, 6, 7, 0, 1, 2};
        int target = 0;
        int index = search(arr, target);
        System.out.println("Element found at index: " + index);
    }

    public static int search(int[] arr, int target) {
        int low = 0, high = arr.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            if (arr[low] <= arr[mid]) {
                if (target >= arr[low] && target <= arr[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else {
                if (target >= arr[mid] && target <= arr[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

### âœ… Dry Run
| Low | High | Mid | arr[mid] | Comparison          | Result   |
|-----|------|-----|----------|--------------------|----------|
| 0   | 6    | 3   | 7        | 7 > target          | Search left |
| 4   | 6    | 5   | 1        | 1 < target          | Search right |
| 4   | 4    | 4   | 0        | 0 == target         | Found     |

ðŸ‘‰ **Output:** Element found at index: 4

### âœ… Time Complexity
| Operation       | Time Complexity     |
|----------------|---------------------|
| Binary Search  | O(log N)             |

### âœ… Space Complexity
| Space Used       | Space Complexity   |
|-----------------|--------------------|
| No Extra Space   | O(1)               |

---

## ðŸ’¡ Approach 3: Optimal Solution (Modified Binary Search)

### âœ… Logic
- Find the pivot where the array is rotated.
- Perform Binary Search on the two halves.
- If found, return the index. Otherwise, return -1.

### ðŸ’» Code (Optimal Solution)
```java
public class SearchInRotatedSortedArray {
    public static void main(String[] args) {
        int arr[] = {4, 5, 6, 7, 0, 1, 2};
        int target = 0;
        int index = search(arr, target);
        System.out.println("Element found at index: " + index);
    }

    public static int search(int[] arr, int target) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            if (arr[low] <= arr[mid]) {
                if (target >= arr[low] && target <= arr[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else {
                if (target >= arr[mid] && target <= arr[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

### âœ… Time Complexity
| Operation     | Time Complexity |
|---------------|-----------------|
| Binary Search | O(log N)        |

### âœ… Space Complexity
| Space Used     | Space Complexity |
|----------------|-----------------|
| No Extra Space | O(1)             |

---

## ðŸ’Ž Comparison of All Approaches
| Approach     | Time Complexity     | Space Complexity |
|-------------|-------------------|-----------------|
| **Brute**    | O(N)                | O(1)            |
| **Better**   | O(log N)            | O(1)            |
| **Optimal**  | O(log N)            | O(1)            |

---