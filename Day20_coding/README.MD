# ðŸ“œ Find Lower Bound, Upper Bound, and Total Occurrences in a Sorted Array

## âœ… Problem Statement
Given a **sorted array of integers** and a **target value**, your task is to:

1. **Find the Lower Bound (First Occurrence)** of the target.
2. **Find the Upper Bound (Last Occurrence)** of the target.
3. **Find the Total Number of Occurrences** of the target.

### ðŸ“Š Example Input & Output

| Input Array         | Target | Lower Bound (First Occurrence) | Upper Bound (Last Occurrence) | Total Occurrences |
|--------------------|--------|--------------------------------------|------------------------------|-------------------|
| {2, 4, 4, 4, 6, 7} | 4      | 1                                | 3                            | 3                 |
| {1, 2, 3, 4, 5, 5} | 5      | 4                                | 5                            | 2                 |
| {1, 2, 3, 4, 5, 6} | 7      | -1                               | -1                           | 0                 |

---

## ðŸ’¡ Approach 1: Brute Force Solution
### âœ… Logic
- Traverse the entire array.
- Track the **first and last occurrence** of the target.
- Count the total occurrences.
- This approach works but is inefficient for large arrays.

### ðŸ’» Code (Brute Force Solution)
```java
public class LowerUpperBound {
    public static void main(String[] args) {
        int arr[] = {2, 4, 4, 4, 6, 7};
        int target = 4;

        int firstOccurrence = -1;
        int lastOccurrence = -1;
        int count = 0;

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                if (firstOccurrence == -1) {
                    firstOccurrence = i;
                }
                lastOccurrence = i;
                count++;
            }
        }

        System.out.println("First Occurrence: " + firstOccurrence);
        System.out.println("Last Occurrence: " + lastOccurrence);
        System.out.println("Total Occurrences: " + count);
    }
}
```

### âœ… Time Complexity
| Operation         | Time Complexity |
|-------------------|-----------------|
| Traverse Array     | O(N)             |

### âœ… Space Complexity
| Space Used         | Space Complexity |
|-------------------|-----------------|
| No Extra Space     | O(1)             |

### âš  Drawback
- Inefficient for large arrays.
- Requires traversing the entire array.

---

## ðŸ’Ž Approach 2: Binary Search (Optimal Solution)
### âœ… Logic
- Use **Binary Search** to find the **first occurrence (Lower Bound)**.
- Use **Binary Search** again to find the **last occurrence (Upper Bound)**.
- The total occurrences = `(last occurrence - first occurrence + 1)`.

### âœ… Steps
1. **Find Lower Bound (First Occurrence)**:
    - Apply binary search and move `high = mid - 1` whenever `arr[mid] == target`.
2. **Find Upper Bound (Last Occurrence)**:
    - Apply binary search and move `low = mid + 1` whenever `arr[mid] == target`.


### ðŸ’» Code (Binary Search)
```java
public class LowerUpperBound {
    public static void main(String[] args) {
        int arr[] = {2, 4, 4, 4, 6, 7};
        int target = 4;

        int firstOccurrence = findFirstOccurrence(arr, target);
        int lastOccurrence = findLastOccurrence(arr, target);

        int totalOccurrences = (firstOccurrence == -1) ? 0 : (lastOccurrence - firstOccurrence + 1);

        System.out.println("First Occurrence: " + firstOccurrence);
        System.out.println("Last Occurrence: " + lastOccurrence);
        System.out.println("Total Occurrences: " + totalOccurrences);
    }

    // Function to find the Lower Bound (First Occurrence)
    static int findFirstOccurrence(int arr[], int target) {
        int low = 0, high = arr.length - 1;
        int first = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                first = mid;
                high = mid - 1; // Keep searching in the left part
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return first;
    }

    // Function to find the Upper Bound (Last Occurrence)
    static int findLastOccurrence(int arr[], int target) {
        int low = 0, high = arr.length - 1;
        int last = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                last = mid;
                low = mid + 1; // Keep searching in the right part
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return last;
    }
}
```

### âœ… Dry Run
| Low | High | Mid | arr[mid] | Action         |
|-----|------|-----|----------|----------------|
| 0   | 5    | 2   | 4        | Found, go left  |
| 0   | 1    | 0   | 2        | Move right     |
| 1   | 1    | 1   | 4        | Found, go left  |

ðŸ‘‰ First Occurrence = **1**

ðŸ‘‰ Last Occurrence = **3**

ðŸ‘‰ Total Occurrences = **3**


### âœ… Time Complexity
| Operation     | Time Complexity |
|---------------|-----------------|
| First Occurrence | O(log N)       |
| Last Occurrence  | O(log N)       |
| Total            | O(log N + log N) = O(log N) |

### âœ… Space Complexity
| Space Used | Space Complexity |
|------------|-----------------|
| No Extra Space | O(1)          |


---

## ðŸ§  Edge Cases
| Case                         | Output              |
|-----------------------------|--------------------|
| Target is less than minimum   | -1, -1, 0          |
| Target is greater than maximum| -1, -1, 0          |
| All elements are same         | first = 0, last = N-1, count = N |
| Single occurrence             | first = last = index |

---

## âœ… Comparison of All Approaches
| Approach     | Time Complexity  | Space Complexity |
|-------------|-----------------|-----------------|
| **Brute Force** | O(N)           | O(1)             |
| **Binary Search** | O(log N)     | O(1)             |

---

## ðŸš€ Conclusion
- âœ… Binary Search is the most optimal approach for finding **Lower Bound, Upper Bound, and Total Occurrences**.
- âœ… This pattern is frequently asked in FAANG-level coding interviews.
- âœ… **Always apply Binary Search** whenever the array is sorted.

---