# ðŸš€ Day 1: Prime Number Check in Java

## ðŸ“œ Problem Statement
Given an integer **N**, write a program to check whether the number is **Prime or Not**.

A **Prime Number** is a number that is only divisible by **1** and **itself**. (Example: 2, 3, 5, 7, 11, 13, 17, 19...)

You need to implement the solution using **four different approaches**:
- âœ… **Brute Force Approach**
- âœ… **Better Approach**
- âœ… **Optimal Approach**
- âœ… **Most Optimal Approach (6kÂ±1 Rule)**

---

## ðŸ’¡ Approach 1: Brute Force (Dividing By All Numbers)

### âœ… Explanation
- Check if the number **N** is divisible by any number from **1 to N**.
- Count the number of divisors.
- If the divisor count == 2 â†’ Prime Number.
- Else â†’ Not a Prime Number.

### ðŸ’» Code
```java
import java.util.*;
public class Brute_checkprime {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = sc.nextInt();
        
        int count = 0;
        for(int i = 1; i <= n; i++) {
            if(n % i == 0) {
                count++;
            }
        }
        
        if(count == 2) {
            System.out.println(n + " is a Prime Number");
        } else {
            System.out.println(n + " is NOT a Prime Number");
        }
    }
}
```

### â© Time Complexity (TC)
- **O(N)** â†’ Iterating from **1 to N**.

### â© Space Complexity (SC)
- **O(1)** â†’ Constant space.

### âŒ Why Is This Approach Not Recommended?
- ðŸ’» It takes too long for large numbers like **10^9**.
- ðŸ˜¢ Highly inefficient.

---

## ðŸ’Ž Approach 2: Better Approach (Iterating Till N/2)

### âœ… Explanation
- A number **N** cannot have any factor beyond **N/2** except itself.
- So, iterate only till **N/2** to reduce the complexity.

### ðŸ’» Code
```java
import java.util.*;
public class Better_checkprime {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = sc.nextInt();
        
        int count = 0;
        for(int i = 1; i <= n/2; i++) {
            if(n % i == 0) {
                count++;
            }
        }
        
        if(count == 1) {
            System.out.println(n + " is a Prime Number");
        } else {
            System.out.println(n + " is NOT a Prime Number");
        }
    }
}
```

### â© Time Complexity (TC)
- **O(N/2)** â†’ Reduced complexity.

### â© Space Complexity (SC)
- **O(1)** â†’ Constant space.

### âŒ Why Is This Approach Still Not Good?
- ðŸ¤¦â€â™‚ï¸ It still takes **half the time** but not efficient for large numbers.

---

## ðŸ’Ž Approach 3: Optimal Approach (Iterating Till âˆšN)

### âœ… Explanation
- Any factor of **N** must appear in a pair.
- For any factor **i**, there exists a factor **N/i**.
- Therefore, **no need to check beyond âˆšN**.

### ðŸ’» Code
```java
import java.util.*;
public class Optimal_check_prime {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = sc.nextInt();
        
        boolean isPrime = true;
        if(n == 1) {
            isPrime = false;
        }
        
        for(int i = 2; i*i <= n; i++) {
            if(n % i == 0) {
                isPrime = false;
                break;
            }
        }
        
        if(isPrime) {
            System.out.println(n + " is a Prime Number");
        } else {
            System.out.println(n + " is NOT a Prime Number");
        }
    }
}
```

### â© Time Complexity (TC)
```sql
for(int i = 2; i*i <= n; i++)
       --> Loop runs only âˆšN times
TC = O(âˆšN)
```

### â© Space Complexity (SC)
- **O(1)** â†’ Constant space.

### ðŸ’¯ Why Is This Approach Best?
- âœ… **Reduced Time Complexity to O(âˆšN)** ðŸ’¯ðŸ”¥
- âœ… Perfect for checking Prime for very large numbers like:
  - **10^6 (1 million)** â†’ Checked in milliseconds. ðŸ˜ŽðŸš€
  - **10^9 (1 billion)** â†’ Still very fast. ðŸ’¯ðŸ”¥

---

## ðŸ’Ž Approach 4: Most Optimal Approach (Using 6kÂ±1 Rule)

### âœ… Explanation
- All Prime Numbers > 3 can be represented in the form of **6kÂ±1**.
- So, instead of checking every number, check only:
  ```java
  i = 5; i*i <= n; i += 6
  ```
- This reduces unnecessary iterations.

### ðŸ’» Code
```java
import java.util.*;
public class Optimal2isprime {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = sc.nextInt();
        
        if(n == 1) {
            System.out.println(n + " is NOT a Prime Number");
            return;
        }
        if(n == 2 || n == 3) {
            System.out.println(n + " is a Prime Number");
            return;
        }
        if(n % 2 == 0 || n % 3 == 0) {
            System.out.println(n + " is NOT a Prime Number");
            return;
        }
        
        for(int i = 5; i*i <= n; i += 6) {
            if(n % i == 0 || n % (i+2) == 0) {
                System.out.println(n + " is NOT a Prime Number");
                return;
            }
        }
        
        System.out.println(n + " is a Prime Number");
    }
}
```

### â© Time Complexity (TC)
- **O(âˆšN)** â†’ Reduced even further.

### â© Space Complexity (SC)
- **O(1)** â†’ Constant space.

### ðŸ’¯ Why Is This The Most Optimal?
- ðŸš€ Handles large values up to **10^18**.
- âœ… Perfect for competitive coding & FAANG interviews.

---

## ðŸŽ¯ Final Comparison
| Approach     | Time Complexity | Space Complexity | Best Use Case             |
|-------------|----------------|-----------------|---------------------------|
| **Brute Force**  | O(N)            | O(1)           | Small numbers             |
| **Better Approach** | O(N/2)         | O(1)           | Moderate numbers          |
| **Optimal Approach** | O(âˆšN)          | O(1)           | Large numbers             |
| **Most Optimal** | O(âˆšN/6)        | O(1)           | Competitive coding        |

---

## ðŸ’¡ Key Takeaway
- ðŸš€ Always optimize from Brute â†’ Better â†’ Optimal.
- âœ… Use **6kÂ±1** rule for large prime numbers.
- ðŸ’¯ Perfect code for FAANG and product-based companies.

