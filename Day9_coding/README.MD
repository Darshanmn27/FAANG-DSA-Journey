# ðŸš€ Day 9: Generate Fibonacci Series

## ðŸ“œ Problem Statement

Given a number **N**, write a program to **generate the Fibonacci series up to N terms**.

The **Fibonacci Series** is a series of numbers where each number is the sum of the two preceding ones, usually starting with **0 and 1**.

### âœ… Example 1:

```
Input: N = 5
Output: 0, 1, 1, 2, 3
```

### âœ… Example 2:

```
Input: N = 7
Output: 0, 1, 1, 2, 3, 5, 8
```

---

## ðŸ’¡ Approach 1: Iterative Solution

### âœ… Explanation

- Start with two initial numbers **0** and **1**.
- Use a loop to generate the next Fibonacci numbers by adding the previous two numbers.
- Print the series up to **N terms**.

### ðŸ’» Code

```java
public class Fibonacci_Iterative {
    public static void main(String[] args) {
        int N = 5;
        int a = 0, b = 1;

        System.out.print(a + ", " + b);

        for (int i = 2; i < N; i++) {
            int next = a + b;
            System.out.print(", " + next);
            a = b;
            b = next;
        }
    }
}
```

### â© Time Complexity (TC)

- **O(N)** â†’ Iterating through N terms.

### â© Space Complexity (SC)

- **O(1)** â†’ Constant space used.

### âŒ Why Is This Approach Basic?

- Requires explicit looping.
- Cannot handle very large N efficiently.

---

## ðŸ’Ž Approach 2: Recursive Solution

### âœ… Explanation

- Use a recursive function to generate Fibonacci numbers.
- Base conditions: If **N = 0 or 1**, return the number itself.
- Otherwise, return the sum of the previous two Fibonacci numbers.

### ðŸ’» Code

```java
public class Fibonacci_Recursive {
    public static int fibonacci(int N) {
        if (N == 0) return 0;
        if (N == 1) return 1;
        return fibonacci(N-1) + fibonacci(N-2);
    }

    public static void main(String[] args) {
        int N = 5;
        for (int i = 0; i < N; i++) {
            System.out.print(fibonacci(i) + ", ");
        }
    }
}
```

### â© Time Complexity (TC)

- **O(2^N)** â†’ Exponential time complexity due to recursive calls.

### â© Space Complexity (SC)

- **O(N)** â†’ Stack space for recursive calls.

### âŒ Why Is This Approach Inefficient?

- Recursive calls increase time complexity.
- Stack overflow can occur for large N.

---

## ðŸ’Ž Approach 3: Dynamic Programming (Optimal Solution)

### âœ… Explanation

- Use an array to store Fibonacci numbers up to **N**.
- Avoid repeated calculations by storing previously computed values.
- This significantly improves performance.

### ðŸ’» Code

```java
public class Fibonacci_DP {
    public static void main(String[] args) {
        int N = 5;
        int[] fib = new int[N];

        fib[0] = 0;
        fib[1] = 1;

        for (int i = 2; i < N; i++) {
            fib[i] = fib[i-1] + fib[i-2];
        }

        for (int i = 0; i < N; i++) {
            System.out.print(fib[i] + ", ");
        }
    }
}
```

### â© Time Complexity (TC)

- **O(N)** â†’ Linear time to generate the series.

### â© Space Complexity (SC)

- **O(N)** â†’ Space used for storing Fibonacci numbers.

### ðŸ’¯ Why Is This Approach The Best?

- âœ… Handles large input efficiently.
- âœ… No repeated calculations.
- âœ… Prevents stack overflow.

---

## ðŸŽ¯ Key Takeaways (FAANG Mindset)

| Approach        | Time Complexity (TC) | Space Complexity (SC) | Efficiency                   |
| --------------- | -------------------- | --------------------- | ---------------------------- |
| **Iterative**   | O(N)                 | O(1)                  | Simple but basic              |
| **Recursive**   | O(2^N)               | O(N)                  | Inefficient for large inputs  |
| **DP (Optimal)**| O(N)                 | O(N)                  | Best for large inputs         |

---

## âœ… Final Thoughts

- ðŸš€ Always think in 3 steps: Iterative â†’ Recursive â†’ Dynamic Programming.
- âœ… In technical interviews, aim to optimize your code step-by-step.
- âœ… The Dynamic Programming (DP) approach is the most recommended.

---

## ðŸ’» Learning Outcome

- âœ… You now understand how to generate Fibonacci Series using three approaches.
- âœ… Practiced writing clean and optimized code.
- âœ… Learned about time and space optimization.

---

## ðŸŽ“ Pro Tip (For Interviews)

- ðŸ’¡ Always tell the interviewer you know **3 approaches**.
- âœ… Start by writing a simple iterative solution.
- âœ… Then optimize it to recursive and finally to dynamic programming.
- ðŸš€ This demonstrates your problem-solving and optimization ability.



