# ðŸš€ Day 16: Find the First and Last Occurrence of an Element in an Array

## âœ… Problem Statement
You are given an integer array `arr[]` of size **N** and a target element `target`. Your task is to find the **first and last occurrence index** of the target element in the array.

If the target is not found, return `{-1, -1}`.

---

## ðŸ“Š Example Input & Output

| Input Array      | Target | Output     |
|----------------|--------|------------|
| {1, 10, 21, 1, 30, 1, 4, 4} | 1      | {0, 5}    |
| {5, 6, 7, 8, 8, 10}  | 8      | {3, 4}    |
| {10, 20, 30, 40}   | 25     | {-1, -1} |

---

## ðŸ’» Approach 1: Brute Force Solution

### ðŸ’¡ Logic
- Traverse the array twice using two loops.
- In the first loop, find the **first occurrence** of the target.
- In the second loop, find the **last occurrence** of the target.
- Return the result as `{first, last}`.

### âœ… Code (Brute Force Solution)
```java
import java.util.*;

public class FirstLastOccurrence {
    public static void main(String[] args) {
        int arr[] = {1, 10, 21, 1, 30, 1, 4, 4};
        int target = 1;
        int n = arr.length;

        int first = -1, last = -1;
        
        // Find the first occurrence
        for(int i = 0; i < n; i++) {
            if(arr[i] == target) {
                first = i;
                break;
            }
        }
        
        // Find the last occurrence
        for(int i = n-1; i >= 0; i--) {
            if(arr[i] == target) {
                last = i;
                break;
            }
        }
        
        System.out.println("{" + first + ", " + last + "}");
    }
}
```

### âœ… Output:
```
{0, 5}
```

### âœ… Dry Run:
| Element | Index | First Occurrence | Last Occurrence |
|---------|-------|------------------|-----------------|
| 1       | 0     | âœ… 0              |                 |
| 10      | 1     |                  |                 |
| 21      | 2     |                  |                 |
| 1       | 3     |                  |                 |
| 30      | 4     |                  |                 |
| 1       | 5     |                  | âœ… 5           |

### âœ… Time Complexity:
| Operation      | Time Complexity     |
|----------------|--------------------|
| First Loop     | O(N)                 |
| Second Loop    | O(N)                 |
| **Total**      | O(N + N) = O(2N)     |

### âœ… Space Complexity:
| Space Used     | Space Complexity     |
|----------------|--------------------|
| No extra space | O(1)                 |

### ðŸš¨ Why Avoid This?
- This approach traverses the array **twice**, resulting in **O(2N)** time complexity.
- Can we do it in **one traversal**? Yes, let's move to a better approach.

---

## ðŸ’» Approach 2: Better Solution (Single Traversal)

### ðŸ’¡ Logic
- Traverse the array **once**.
- Track the first occurrence using a variable `first`.
- Track the last occurrence using another variable `last`.
- Return `{first, last}`.

### âœ… Code (Better Solution)
```java
import java.util.*;

public class FirstLastOccurrence {
    public static void main(String[] args) {
        int arr[] = {1, 10, 21, 1, 30, 1, 4, 4};
        int target = 1;
        int n = arr.length;

        int first = -1, last = -1;

        for(int i = 0; i < n; i++) {
            if(arr[i] == target) {
                if(first == -1) {
                    first = i;
                }
                last = i;
            }
        }
        
        System.out.println("{" + first + ", " + last + "}");
    }
}
```

### âœ… Output:
```
{0, 5}
```

### âœ… Dry Run:
| Element | Index | First Occurrence | Last Occurrence |
|---------|-------|------------------|-----------------|
| 1       | 0     | âœ… 0              | âœ… 0           |
| 10      | 1     |                  |                 |
| 21      | 2     |                  |                 |
| 1       | 3     |                  | âœ… 3           |
| 30      | 4     |                  |                 |
| 1       | 5     |                  | âœ… 5           |

### âœ… Time Complexity:
| Operation      | Time Complexity     |
|----------------|--------------------|
| Single Loop    | O(N)                 |

### âœ… Space Complexity:
| Space Used     | Space Complexity     |
|----------------|--------------------|
| No extra space | O(1)                 |

### ðŸš€ Why Is This Better?
- It uses **single traversal (O(N))** instead of two.
- It still uses **constant space (O(1))**.
- But can we do it faster using Binary Search? Yes! ðŸ’¯ðŸ”¥

---

## ðŸ’» Approach 3: Optimal Solution (Binary Search)

### ðŸ’¡ Logic
- Use **Binary Search** to find the **first occurrence**.
- Use **Binary Search** again to find the **last occurrence**.
- Binary Search reduces time complexity to **O(log N)**.

### âœ… Code (Optimal Solution)
```java
import java.util.*;

public class FirstLastOccurrence {

    public static int firstOccurrence(int arr[], int target) {
        int low = 0, high = arr.length - 1, first = -1;
        while(low <= high) {
            int mid = low + (high - low) / 2;
            if(arr[mid] == target) {
                first = mid;
                high = mid - 1;
            } else if(arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return first;
    }

    public static int lastOccurrence(int arr[], int target) {
        int low = 0, high = arr.length - 1, last = -1;
        while(low <= high) {
            int mid = low + (high - low) / 2;
            if(arr[mid] == target) {
                last = mid;
                low = mid + 1;
            } else if(arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return last;
    }
}
```

### âœ… Time Complexity:
| Operation      | Time Complexity     |
|----------------|--------------------|
| Binary Search  | O(log N)            |

### âœ… Space Complexity:
| Space Used     | Space Complexity     |
|----------------|--------------------|
| No extra space | O(1)                 |

---

## ðŸš€ Conclusion
| Approach    | Time Complexity | Space Complexity |
|-------------|-----------------|-------------------|
| Brute Force | O(2N)            | O(1)             |
| Better      | O(N)             | O(1)             |
| Optimal     | O(log N)         | O(1)             |

